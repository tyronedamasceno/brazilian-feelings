# -*- coding: utf-8 -*-
"""plotagem do mapa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LFZ6XksSfIZ9_CdrTMMOvHyDSvHuscdQ

## Upload dos arquivos

Nos blocos de código abaixo devem ser fornecidos (carregados) o arquivo de dataset (.csv) contendo os dados de polaridade e localização (latitude e longitude) dos tweets e o arquivo *GeoJSON* com os formatos dos estados do Brasil (**brazil-states.geojson** obtido em https://github.com/codeforamerica/click_that_hood/blob/master/public/data/brazil-states.geojson).

Na célula abaixo, escreva o nome do arquivo de dataset sem a extensão .csv

**PS.:** Basta modificar o valor no formulário que o código executará automaticamente.
"""

# Upload dos arquivos
from google.colab import files
uploaded = files.upload()
for fn in uploaded.keys():
  print('Arquivo "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#@title Nome do arquivo de dados sem a extensão .csv { display-mode: "form", run: "auto" }

file_name = 'Haddad2000' #@param {type:"string"}

"""## Instalação e *import* dos módulos"""

# Instalando dependências
!pip install folium shapely

import folium
from folium.plugins import HeatMap
import json
import pandas as pd
from branca.colormap import linear
from shapely.geometry import shape, Point

"""## Leitura e limpeza dos dados

A célula abaixo puramente lê o arquivo .csv fornecido para um **pandas.DataFrame** e imprime seu cabeçalho e informações.
"""

tweets = pd.read_csv(file_name + '.csv', sep=';')
display(tweets.head())
display(tweets.info())

"""É possível notar que há uma coluna desnecessária: **`'Unnamed: 0'`**, vamos excluí-la e também descartar as entradas com tweets sem coordenadas de localização."""

# desconsideraremos os tweets sem localização
tweets = tweets.drop('Unnamed: 0', axis='columns')
tweets = tweets.dropna(subset=['Latitude', 'Longitude'])
tweets.info()

"""# Plotagem dos mapas

## Colormap

Para visualização dos tweets no map, será utilizado como coloração o valor de polaridade sentimental, valor que vai de -1 (ruim:  <font color="red">vermelho</font>) e 1 (bom:  <font color="blue">azul</font>)
"""

# colormap vermelho (ruim) para azul (bom)
colormap = linear.RdBu_03.scale(-1, 1)
colormap

"""## Mapa com pontos

Para visualização de todos os tweets localizáveis no mapa, são utilizados marcadores circulares com a coloração indicativa de sua polaridade. É possível clicar em um ponto para visualizar o valor de polaridade.
"""

# put your code here
map_points = folium.Map(
    location=[0.0000000, 25.000000],
    zoom_start=3,
    tiles='Stamen Terrain',
)

for i, tweet in tweets.iterrows():
  folium.CircleMarker([tweet['Latitude'],tweet['Longitude']],
                      popup='polaridade: %f'%(tweet['polarity']),
                      radius=8, 
                      color='#000000',
                      weight=1,
                      fill=True, 
                      fill_color=colormap(tweet['polarity']),
                      fill_opacity=1.0).add_to(map_points)
  
  colormap.caption = 'Polaridade dos tweets'
  colormap.add_to(map_points)
  
map_points.save(file_name + '_points.html')
display(map_points)

"""## Mapas de calor

O código abaixo gera três mapas de calor de acordo com densidade de tweets. O primeiros dos mapas mostra todos os tweets, o segundo os tweets com avaliação de polaridade bastante positiva (> 0.5) e, por fim, o terceiro mostra os tweets com polaridade bastante negativa (< -0.5)
"""

# Mapas de calor com todos os tweets e os mais exacerbados (polaridade > 0.5 e < -0.5)

m = []
for i in range(3):
  m.append(folium.Map(
      location=[0.0000000, 25.000000],
      zoom_start=3,
      tiles='Stamen Terrain',
  ))

total_data = tweets.loc[:, ['Latitude', 'Longitude', 'polarity']].values
HeatMap(total_data).add_to(m[0])
                        
positive_data = tweets.loc[tweets['polarity'] > 0.5, ['Latitude', 'Longitude', 'polarity']].values
HeatMap(positive_data).add_to(m[1])
                        
negative_data = tweets.loc[tweets['polarity'] < -0.5, ['Latitude', 'Longitude', 'polarity']].values
HeatMap(negative_data).add_to(m[2])

m[0].save(file_name + '_heat_total.html')
m[1].save(file_name + '_heat_positive.html')
m[2].save(file_name + '_heat_megative.html')

display(m[0])
display(m[1])
display(m[2])

"""### Carregamento do arquivo GeoJSON"""

#Fonte: https://github.com/codeforamerica/click_that_hood/blob/master/public/data/brazil-states.geojson
geo_json_data = json.load(open('brazil-states.geojson'))

"""## Distribuição dos tweets por estado brasileiro

A célula de código abaixo gera um dicionário com todos os estados e sua forma geográfica, obtidos do arquivo *GeoJSON*. E, em seguida, itera pelo *DataFrame* dos tweets, para que estes sejam contabilizados no seu estado federativo (basicamente checa se o ponto geográfico está dentro do território do estado, e adiciona seu valor à estatística).

Logo após, é mostrado o *DataFrame* obtido a partir do dicionario.
"""

# Monta um dicionário com todos os estados mais exterior
states = {}

for state in geo_json_data['features']:
    states[state['properties']['name']] = {
        'shape': shape(state['geometry']),
        'count':0,
        'sum':0,
        'mean':0,
        'min':0,
        'max':0
    }
exterior = {'shape': None, 'count':0, 'sum':0, 'mean':0, 'min':0, 'max':0}
    
    
# Agora, para todos os tweets...
for i, tweet in tweets.iterrows():
  #gera um ponto (x, y) com o local (long, lat) do tweet
  tweet_local = Point(tweet['Longitude'], tweet['Latitude'])
  
  #checa se a localização do tweet está dentro de algum dos estados brasileiros
  for name, state in states.items():
    if state['shape'].contains(tweet_local):
      state['count'] += 1
      state['sum'] += tweet['polarity']
      state['mean'] = state['sum'] / state['count']
      state['min'] = min(tweet['polarity'], state['min'])
      state['max'] = max(tweet['polarity'], state['max'])
      break
  #se não estiver, vai para contagem do exterior
  else:
    exterior['count'] += 1
    exterior['sum'] += tweet['polarity']
    exterior['mean'] = exterior['sum'] / exterior['count']
    exterior['min'] = min(tweet['polarity'], exterior['min'])
    exterior['max'] = max(tweet['polarity'], exterior['max'])

states['Exterior'] = exterior

states_df = pd.DataFrame(states).drop(['shape', 'sum'], axis='index').transpose()
display(states_df)

"""### Colormap adaptado

Como a utilização do colormap anterior (com interpolação de -1.0 a 1.0) geraria um mapa com coloração clara e com pouco contrastre, o código abaixo determina o maior valor absoluto entre a menor e maior média de polaridade dos estados e gera um colormap com a interpolação do negativo deste valor ao positivo. Desta forma obtem-se um melhor contraste do mapa.
"""

#determina o maior valor absoluto das médias para gerar um colormap com maior contraste
edge_val = max(abs(states_df['mean'].min()), abs(states_df['mean'].max()))

enhanced_colormap = linear.RdBu_03.scale(-edge_val, edge_val)
enhanced_colormap

"""### Mapa coroplético

O código abaixo gera um mapa com os estados coloridos de acordo com a polaridade média dos seus tweets, utilizando a escala colorimétrica (colormap) gerada acima.
"""

map_choropleth = folium.Map(
    location=[-16.000000, -55.000000],
    zoom_start=5,
    tiles='Stamen Terrain'
)

# Gera o mapa do Brasil
folium.GeoJson(geo_json_data,
               name='Média dos sentimentos dos tweets por estado',
               style_function=lambda state: {
                   'fillColor': '#d3d3d3' if states[state['properties']['name']]['count'] == 0
                   else enhanced_colormap(states[state['properties']['name']]['mean']),
                   'color': 'black',
                   'weight': 1,
                   'dashArray': '5, 5',
                   'fillOpacity': 0.9,
               }).add_to(map_choropleth)

enhanced_colormap.caption = 'Polaridade dos tweets'
enhanced_colormap.add_to(map_choropleth)

map_choropleth.save(file_name + '_choropleth.html')
display(map_choropleth)

"""## Download dos arquivos dos mapas

Todos os códigos que geram mapas salvaram um arquivo .html para cada mapa. Se estiver executando este ***notebook*** no [Google Colab](https://colab.research.google.com/), estes arquivos podem ser baixados na aba *Files* do painel lateral.
"""